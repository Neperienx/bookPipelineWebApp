{% extends "base.html" %}

{% block title %}{{ project.title }} • Book Pipeline Studio{% endblock %}

{% block content %}
<div class="row justify-content-center">
  <div class="col-12 col-lg-10">
    <div class="card frosted-card border-0 shadow-sm mb-4">
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
          <div>
            <h1 class="h4 text-white fw-semibold mb-1">{{ project.title }}</h1>
            <p class="text-white-50 mb-0">{{ project.description or "No description provided yet." }}</p>
          </div>
          <div class="text-md-end">
            <span class="badge rounded-pill bg-primary-subtle text-primary-emphasis me-2">{{ project.status.replace('_', ' ').title() }}</span>
            <span class="badge rounded-pill bg-secondary-subtle text-secondary-emphasis">Current step: {{ project.current_step.replace('_', ' ').title() }}</span>
          </div>
        </div>

        <div class="stage-status-list mb-4">
          <h2 class="h6 text-white text-uppercase mb-3">Stage status</h2>
          <ul class="list-group">
            {% for stage_id, stage_data in stage_generation_steps.items() %}
            {% set entry = stage_entries.get(stage_id) %}
            <li
              class="list-group-item d-flex justify-content-between align-items-start flex-column flex-md-row gap-3 stage-status-item"
              data-stage-status
              data-stage="{{ stage_id }}"
              data-stage-label="{{ stage_data.label | e }}"
              role="button"
              tabindex="0"
            >
              <div>
                <div class="text-white fw-semibold">{{ stage_data.label }}</div>
                <div class="small text-white-50">
                  {% if entry and entry.updated_at %}
                  Updated {{ entry.updated_at.strftime('%b %d, %Y %H:%M') }}
                  {% else %}
                  Awaiting input
                  {% endif %}
                </div>
              </div>
              <span class="badge rounded-pill {% if entry %}bg-success-subtle text-success-emphasis{% else %}bg-dark-subtle text-white-50{% endif %}">
                {% if entry %}Complete{% else %}Pending{% endif %}
              </span>
            </li>
            {% endfor %}
          </ul>
        </div>

        <div class="stage-detail-panel" id="stageDetailPanel">
          <div class="card frosted-card border-0 shadow-sm">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-start mb-3">
                <div>
                  <h3 class="h6 text-white mb-1" id="stageDetailLabel">Stage detail</h3>
                  <div class="text-white-50 small" id="stageDetailUpdated">Select a stage to preview its saved content.</div>
                </div>
                <span class="badge rounded-pill bg-dark-subtle text-white-50" id="stageDetailStatus">Pending</span>
              </div>
              <div class="text-warning small d-none" id="stageDetailFallback">This result used the fallback generator.</div>
              <div class="text-white-50" id="stageDetailEmpty">Pick a stage from the list to view the latest prompts and generated text.</div>
              <div class="stage-detail-content d-none" id="stageDetailContent">
                <div class="mb-3">
                  <div class="text-white-50 text-uppercase small fw-semibold mb-2">System prompt</div>
                  <div class="stage-detail-field" id="stageDetailSystem">No system prompt saved yet.</div>
                </div>
                <div class="mb-3">
                  <div class="text-white-50 text-uppercase small fw-semibold mb-2">User input</div>
                  <div class="stage-detail-field" id="stageDetailUser">No user input saved yet.</div>
                </div>
                <div>
                  <div class="text-white-50 text-uppercase small fw-semibold mb-2">Generated output</div>
                  <div class="stage-detail-field" id="stageDetailOutput">No generated output saved yet.</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div
          id="stageWorkspace"
          data-stage-endpoint="{{ url_for('projects.generate_stage', project_id=project.id) }}"
          data-stage-config='{{ stage_client_config | tojson }}'
          data-stage-entries='{{ stage_client_entries | tojson }}'
        >
          <div class="mb-3">
            <div class="text-white-50 text-uppercase small fw-semibold mb-2">Select a stage</div>
            <div class="btn-group stage-selector" role="group" aria-label="Stage selector">
              {% for stage_id, stage_data in stage_generation_steps.items() %}
              <button
                type="button"
                class="btn btn-outline-light stage-button {% if loop.first %}active{% endif %}"
                data-stage-button
                data-stage="{{ stage_id }}"
              >
                {{ stage_data.label }}
              </button>
              {% endfor %}
            </div>
            <p class="text-white-50 small mt-3" data-stage-description>Choose a stage to load its guidance and saved progress.</p>
          </div>

          <div class="mb-3">
            <label class="form-label text-white fw-semibold" for="systemPrompt">System prompt</label>
            <textarea class="form-control" id="systemPrompt" rows="4" placeholder="Provide high-level instructions for the generator."></textarea>
          </div>

          <div class="mb-3">
            <label class="form-label text-white fw-semibold" for="userPrompt">Your input</label>
            <textarea class="form-control" id="userPrompt" rows="5" placeholder="Describe the idea, characters, or beats you would like to explore."></textarea>
          </div>

          <div class="d-flex flex-column flex-md-row align-items-md-center gap-3 mb-3">
            <button class="btn btn-primary rounded-pill px-4" type="button" id="generateStageButton">Generate</button>
            <div class="progress flex-grow-1 d-none" id="generationProgress">
              <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 100%"></div>
            </div>
            <div class="text-white-50 small" id="generationStatus">Select a stage to begin.</div>
          </div>

          <div class="alert alert-danger d-none" id="generationError"></div>

          <div class="mt-4">
            <div class="d-flex justify-content-between align-items-start mb-2">
              <h3 class="h6 text-white mb-0" id="outputHeading">Latest output</h3>
              <span class="badge rounded-pill bg-dark-subtle text-white-50" id="outputMeta">No generation yet</span>
            </div>
            <div class="stage-output" id="stageOutput">Run a generation to see results here.</div>
          </div>
        </div>
    </div>
  </div>

    {% set active_concept_outline = concept_outline_id or (selected_outline.id if selected_outline else None) %}
    {% set concept_source_outline = (outlines | selectattr('id', 'equalto', concept_outline_id) | list | first) %}
    <div
      class="card frosted-card border-0 shadow-sm mb-4"
      data-concept-workspace
      data-concept-endpoint="{{ url_for('projects.generate_concepts', project_id=project.id) }}"
      data-concept-outline="{{ (concept_outline_id or '') }}"
      data-concept-concepts='{{ concept_client_entries | tojson }}'
      data-concept-used-fallback="{{ 'true' if concept_used_fallback else 'false' }}"
    >
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
          <div>
            <h2 class="h6 text-white text-uppercase mb-1">Concept clarifications</h2>
            <p class="text-white-50 small mb-0">
              Surface ambiguous ideas from the outline and capture crisp definitions with concrete examples.
            </p>
          </div>
          <div class="d-flex flex-wrap gap-2">
            <button class="btn btn-outline-light btn-sm rounded-pill" type="button" data-concept-refresh>
              Clarify concepts
            </button>
          </div>
        </div>

        <div class="mb-4">
          <label class="form-label text-white fw-semibold" for="conceptOutlineSelect">Outline source</label>
          <select class="form-select" id="conceptOutlineSelect" data-concept-outline>
            <option value="" {% if not active_concept_outline %}selected{% endif %}>Select an outline…</option>
            {% for outline in outlines %}
            <option value="{{ outline.id }}" {% if active_concept_outline == outline.id %}selected{% endif %}>
              {{ outline.title }}
            </option>
            {% endfor %}
          </select>
          <div class="text-white-50 small mt-2" data-concept-status>
            {% if concepts %}
            {% set concept_count = concepts | length %}
            Clarified {{ concept_count }} concept{{ '' if concept_count == 1 else 's' }}{% if concept_source_outline %}
              from &ldquo;{{ concept_source_outline.title }}&rdquo;{% endif %}. Generate again to refresh.
            {% else %}
            Pick an outline to review and clarify its concepts.
            {% endif %}
          </div>
          <div class="text-warning small mt-2 {% if not concept_used_fallback %}d-none{% endif %}" data-concept-fallback>
            Latest concepts used the fallback generator. Review and adjust the details before saving.
          </div>
        </div>

        <div class="concept-results">
          <div class="concept-empty {% if concepts %}d-none{% endif %}" data-concept-empty>
            <div class="concept-empty-inner">
              <h3 class="h6 text-white mb-1">No concept clarifications yet</h3>
              <p class="text-white-50 small mb-0">Choose an outline and run the assistant to define fuzzy ideas.</p>
            </div>
          </div>
          <div class="concept-list" data-concept-list>
            {% for concept in concepts %}
            <article class="concept-entry">
              <div class="d-flex justify-content-between align-items-start mb-2">
                <h3 class="h6 text-white mb-0">{{ concept.name }}</h3>
                {% if concept.clarity_issue %}
                <span class="badge rounded-pill bg-dark-subtle text-white-50 small">Needs clarity</span>
                {% endif %}
              </div>
              {% if concept.clarity_issue %}
              <p class="text-white-50 small mb-2 concept-issue">{{ concept.clarity_issue }}</p>
              {% endif %}
              <p class="text-white-50 mb-2">{{ concept.definition }}</p>
              {% if concept.examples_list %}
              <ul class="concept-examples">
                {% for example in concept.examples_list %}
                <li>{{ example }}</li>
                {% endfor %}
              </ul>
              {% endif %}
            </article>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>

    <div class="card frosted-card border-0 shadow-sm">
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
          <div>
            <h2 class="h6 text-white text-uppercase mb-1">Character roster</h2>
            <p class="text-white-50 small mb-0">Browse the cast and update their motivations, conflicts, and notes.</p>
          </div>
          <div class="d-flex flex-wrap gap-2">
            <a
              class="btn btn-outline-light btn-sm rounded-pill"
              href="{{ url_for('projects.detail', project_id=project.id, character_id='new') }}"
              data-character-new
            >
              Add new character
            </a>
          </div>
        </div>

        <div class="row g-4 align-items-start">
          <div class="col-12 col-lg-7">
            <div
              class="row row-cols-1 row-cols-sm-2 g-3"
              data-character-roster
              data-selected-id="{{ selected_character.id if selected_character else '' }}"
            >
              {% if characters %}
              {% for character in characters %}
              <div class="col">
                <a
                  href="{{ url_for('projects.detail', project_id=project.id, character_id=character.id) }}"
                  class="character-tile card h-100 text-decoration-none"
                  data-character-entry
                  data-character-id="{{ character.id }}"
                  data-character='{{ {
                    "id": character.id,
                    "name": character.name,
                    "role": character.role or "",
                    "background": character.background or "",
                    "goals": character.goals or "",
                    "conflict": character.conflict or "",
                    "notes": character.notes or "",
                  } | tojson | forceescape }}'
                >
                  <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                      <h3 class="h6 text-white mb-0">{{ character.name }}</h3>
                      {% if character.role %}
                      <span class="badge rounded-pill bg-dark-subtle text-white-50 small">{{ character.role }}</span>
                      {% endif %}
                    </div>
                    <p class="text-white-50 small mb-2">{{ (character.background or character.goals or character.notes or 'No summary yet.') | truncate(120, True, '…') }}</p>
                    <div class="text-white-50 extra-meta small">
                      {% set detail_count = (1 if character.background else 0) + (1 if character.goals else 0) + (1 if character.conflict else 0) + (1 if character.notes else 0) %}
                      <span>{{ detail_count }} detail{{ '' if detail_count == 1 else 's' }} captured</span>
                    </div>
                  </div>
                </a>
              </div>
              {% endfor %}
              {% else %}
              <div class="col">
                <div class="character-empty state card h-100">
                  <div class="card-body d-flex flex-column justify-content-center text-center p-4">
                    <h3 class="h6 text-white mb-2">No characters yet</h3>
                    <p class="text-white-50 small mb-3">Start by adding a character to build out your cast roster.</p>
                    <a class="btn btn-primary btn-sm rounded-pill" href="{{ url_for('projects.detail', project_id=project.id, character_id='new') }}">Create your first character</a>
                  </div>
                </div>
              </div>
              {% endif %}
            </div>
          </div>
          <div class="col-12 col-lg-5">
            <div class="character-form card frosted-card h-100">
              <div class="card-body">
                <form
                  method="post"
                  action="{{ url_for('projects.detail', project_id=project.id) }}"
                  data-character-form
                  data-title-new="Create a character profile"
                  data-title-edit="Edit {name}"
                  data-subtitle-new="Fill in the details below to add them to the roster."
                  data-subtitle-edit="Update the fields and save your changes."
                  data-autofill-endpoint="{{ url_for('projects.generate_character_profile', project_id=project.id) }}"
                >
                  {{ character_form.csrf_token }}
                  {{ character_form.character_id(class_='d-none', data_character_field='id') }}
                  <div class="mb-3">
                    <h3 class="h6 text-white mb-1" data-character-form-title>
                      {% if selected_character %}Edit {{ selected_character.name }}{% else %}Create a character profile{% endif %}
                    </h3>
                    <p class="text-white-50 small mb-0" data-character-form-subtitle>
                      {% if selected_character %}Update the fields and save your changes.{% else %}Fill in the details below to add them to the roster.{% endif %}
                    </p>
                  </div>

                  <div class="mb-4">
                    <label class="form-label text-white fw-semibold mb-1" for="{{ character_form.seed_prompt.id }}">
                      Jump-start with a quick prompt
                    </label>
                    <p class="text-white-50 small mb-2">
                      Describe who this character should be and let the assistant draft concise details for each field.
                    </p>
                    {{ character_form.seed_prompt(
                      class_='form-control',
                      rows=3,
                      placeholder='Example: A rebellious botanist leading a covert resistance inside a corporate colony.',
                      data_character_autofill_field='prompt'
                    ) }}
                    <div class="d-flex flex-column flex-sm-row gap-2 align-items-sm-center mt-2">
                      <button
                        class="btn btn-outline-light btn-sm rounded-pill"
                        type="button"
                        data-character-autofill-button
                      >
                        Generate fields
                      </button>
                      <div class="text-white-50 small" data-character-autofill-status>
                        Fields stay blank until you ask for help.
                      </div>
                    </div>
                  </div>

                  <div class="mb-3">
                    {{ character_form.name.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.name(class_='form-control', placeholder='Character name', data_character_field='name') }}
                  </div>
                  <div class="mb-3">
                    {{ character_form.role.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.role(class_='form-control', placeholder='Role in the story', data_character_field='role') }}
                  </div>
                  <div class="mb-3">
                    {{ character_form.background.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.background(class_='form-control', rows=3, placeholder='Origins, personal history, or defining traits', data_character_field='background') }}
                  </div>
                  <div class="mb-3">
                    {{ character_form.goals.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.goals(class_='form-control', rows=3, placeholder='What drives them forward?', data_character_field='goals') }}
                  </div>
                  <div class="mb-3">
                    {{ character_form.conflict.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.conflict(class_='form-control', rows=3, placeholder='Who or what stands in their way?', data_character_field='conflict') }}
                  </div>
                  <div class="mb-4">
                    {{ character_form.notes.label(class_='form-label text-white fw-semibold') }}
                    {{ character_form.notes(class_='form-control', rows=3, placeholder='Additional ensemble or relationship notes', data_character_field='notes') }}
                  </div>

                  <div class="d-flex flex-column flex-md-row gap-2 align-items-md-center justify-content-between">
                    <div class="text-white-50 small" data-character-form-status>
                      {% if selected_character %}Currently editing {{ selected_character.name }}.{% else %}Ready to capture a new character.{% endif %}
                    </div>
                    {{ character_form.submit(class_='btn btn-primary rounded-pill px-4') }}
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
  (function () {
    const workspace = document.getElementById('stageWorkspace');
    if (!workspace) {
      return;
    }

    const endpoint = workspace.getAttribute('data-stage-endpoint');
    const config = JSON.parse(workspace.getAttribute('data-stage-config') || '{}');
    const existingEntries = JSON.parse(workspace.getAttribute('data-stage-entries') || '{}');

    const stageButtons = workspace.querySelectorAll('[data-stage-button]');
    const stageStatusItems = document.querySelectorAll('[data-stage-status]');
    const description = workspace.querySelector('[data-stage-description]');
    const systemPromptField = document.getElementById('systemPrompt');
    const userPromptField = document.getElementById('userPrompt');
    const generateButton = document.getElementById('generateStageButton');
    const progress = document.getElementById('generationProgress');
    const status = document.getElementById('generationStatus');
    const output = document.getElementById('stageOutput');
    const outputHeading = document.getElementById('outputHeading');
    const outputMeta = document.getElementById('outputMeta');
    const errorBox = document.getElementById('generationError');
    const detailPanel = document.getElementById('stageDetailPanel');
    const detailLabel = document.getElementById('stageDetailLabel');
    const detailUpdated = document.getElementById('stageDetailUpdated');
    const detailStatus = document.getElementById('stageDetailStatus');
    const detailContent = document.getElementById('stageDetailContent');
    const detailEmpty = document.getElementById('stageDetailEmpty');
    const detailSystem = document.getElementById('stageDetailSystem');
    const detailUser = document.getElementById('stageDetailUser');
    const detailOutput = document.getElementById('stageDetailOutput');
    const detailFallback = document.getElementById('stageDetailFallback');

    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    const csrfToken = csrfMeta ? csrfMeta.getAttribute('content') : '';

    let currentStage = stageButtons.length ? stageButtons[0].getAttribute('data-stage') : null;

    const getStageLabel = (stageId) => {
      if (!stageId) {
        return '';
      }
      const matchingItem = Array.from(stageStatusItems || []).find(
        (item) => item.getAttribute('data-stage') === stageId,
      );
      if (matchingItem) {
        return matchingItem.getAttribute('data-stage-label') || '';
      }
      const defaults = config[stageId] || {};
      return defaults.label || stageId.replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
    };

    const setStatusBadge = (badge, isComplete) => {
      if (!badge) {
        return;
      }
      badge.className = `badge rounded-pill ${
        isComplete ? 'bg-success-subtle text-success-emphasis' : 'bg-dark-subtle text-white-50'
      }`;
      badge.textContent = isComplete ? 'Complete' : 'Pending';
    };

    const updateStageDetail = (stageId) => {
      if (!detailPanel || !stageId) {
        return;
      }

      const defaults = config[stageId] || {};
      const history = existingEntries[stageId] || null;

      const label = getStageLabel(stageId);
      if (detailLabel) {
        detailLabel.textContent = label || 'Stage detail';
      }

      if (detailUpdated) {
        if (history && history.updated_at) {
          detailUpdated.textContent = `Updated ${new Date(history.updated_at).toLocaleString()}`;
        } else {
          detailUpdated.textContent = history ? 'Saved result (timestamp unavailable).' : 'Awaiting input';
        }
      }

      setStatusBadge(detailStatus, Boolean(history));

      if (detailFallback) {
        if (history && history.used_fallback) {
          detailFallback.classList.remove('d-none');
        } else {
          detailFallback.classList.add('d-none');
        }
      }

      if (detailEmpty) {
        detailEmpty.classList.add('d-none');
      }
      if (detailContent) {
        detailContent.classList.remove('d-none');
      }

      const systemPrompt = (history && history.system_prompt) || defaults.system_prompt || '';
      const userPrompt = history && history.user_prompt ? history.user_prompt : '';
      const generatedText = history && history.generated_text ? history.generated_text : '';

      if (detailSystem) {
        detailSystem.textContent = systemPrompt || 'No system prompt saved yet.';
      }
      if (detailUser) {
        detailUser.textContent = userPrompt || 'No user input saved yet.';
      }
      if (detailOutput) {
        detailOutput.textContent = generatedText || 'No generated output saved yet.';
      }
    };

    const applyStageState = (stageId) => {
      const defaults = config[stageId] || {};
      const history = existingEntries[stageId] || {};

      if (description) {
        description.textContent = defaults.description || 'Provide a prompt and generate to fill this stage.';
      }

      const systemPrompt = history.system_prompt || defaults.system_prompt || '';
      systemPromptField.value = systemPrompt;
      userPromptField.value = history.user_prompt || '';

      const outputText = history.generated_text || '';
      if (outputText) {
        output.innerText = outputText;
        output.classList.add('has-content');
        outputMeta.textContent = history.updated_at ? `Updated ${new Date(history.updated_at).toLocaleString()}` : 'Saved result';
      } else {
        output.innerText = 'Run a generation to see results here.';
        output.classList.remove('has-content');
      outputMeta.textContent = 'No generation yet';
      }

      outputHeading.textContent = defaults.label ? `${defaults.label} output` : 'Latest output';
      status.textContent = 'Ready to generate.';
      if (errorBox) {
        errorBox.classList.add('d-none');
        errorBox.textContent = '';
      }
    };

    const setActiveStage = (stageId) => {
      currentStage = stageId;
      stageButtons.forEach((button) => {
        const matches = button.getAttribute('data-stage') === stageId;
        button.classList.toggle('active', matches);
      });
      if (stageStatusItems && stageStatusItems.length) {
        stageStatusItems.forEach((item) => {
          const matches = item.getAttribute('data-stage') === stageId;
          item.classList.toggle('active', matches);
          item.setAttribute('aria-pressed', matches ? 'true' : 'false');
        });
      }
      applyStageState(stageId);
      updateStageDetail(stageId);
    };

    stageButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const stageId = button.getAttribute('data-stage');
        if (!stageId) {
          return;
        }
        setActiveStage(stageId);
      });
    });

    if (stageStatusItems && stageStatusItems.length) {
      const handleStageStatusSelection = (stageId) => {
        if (!stageId) {
          return;
        }
        setActiveStage(stageId);
      };

      stageStatusItems.forEach((item) => {
        item.addEventListener('click', () => {
          handleStageStatusSelection(item.getAttribute('data-stage'));
        });
        item.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            handleStageStatusSelection(item.getAttribute('data-stage'));
          }
        });
      });
    }

    const toggleLoading = (isLoading) => {
      if (isLoading) {
        generateButton.setAttribute('disabled', 'disabled');
        generateButton.textContent = 'Generating…';
        progress.classList.remove('d-none');
        status.textContent = 'The generator is working on this stage…';
      } else {
        generateButton.removeAttribute('disabled');
        generateButton.textContent = 'Generate';
        progress.classList.add('d-none');
      }
    };

    const showError = (message) => {
      if (!errorBox) {
        return;
      }
      errorBox.textContent = message;
      errorBox.classList.remove('d-none');
    };

    const hideError = () => {
      if (!errorBox) {
        return;
      }
      errorBox.classList.add('d-none');
      errorBox.textContent = '';
    };

    generateButton.addEventListener('click', async () => {
      if (!currentStage || !endpoint) {
        return;
      }

      const userPrompt = userPromptField.value.trim();
      if (!userPrompt) {
        showError('Add a short description so the generator has something to build on.');
        userPromptField.focus();
        return;
      }

      hideError();
      toggleLoading(true);

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken || '',
            'X-CSRF-Token': csrfToken || '',
          },
          body: JSON.stringify({
            stage: currentStage,
            prompt: userPrompt,
            system_prompt: systemPromptField.value,
          }),
        });

        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Unable to generate text right now.');
        }

        existingEntries[currentStage] = {
          system_prompt: payload.system_prompt || systemPromptField.value || '',
          user_prompt: userPrompt,
          generated_text: payload.content || '',
          updated_at: payload.updated_at || null,
          used_fallback: payload.used_fallback || false,
        };

        applyStageState(currentStage);
        status.textContent = payload.updated_at
          ? `Saved ${new Date(payload.updated_at).toLocaleString()}`
          : 'Draft saved.';
        updateStageDetail(currentStage);
      } catch (error) {
        const message = error instanceof Error ? error.message : 'We could not generate text at the moment.';
        showError(message);
        status.textContent = 'Generation failed. Please try again.';
      } finally {
        toggleLoading(false);
      }
    });

    if (currentStage) {
      setActiveStage(currentStage);
    } else if (stageStatusItems && stageStatusItems.length) {
      const firstStage = stageStatusItems[0].getAttribute('data-stage');
      if (firstStage) {
        updateStageDetail(firstStage);
      }
    }
  })();

  (function () {
    const panel = document.querySelector('[data-concept-workspace]');
    if (!panel) {
      return;
    }

    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    const csrfToken = csrfMeta ? csrfMeta.getAttribute('content') : '';

    const endpoint = panel.getAttribute('data-concept-endpoint') || '';
    const outlineSelect = panel.querySelector('[data-concept-outline]');
    const refreshButton = panel.querySelector('[data-concept-refresh]');
    const listContainer = panel.querySelector('[data-concept-list]');
    const emptyState = panel.querySelector('[data-concept-empty]');
    const statusNode = panel.querySelector('[data-concept-status]');
    const fallbackNotice = panel.querySelector('[data-concept-fallback]');
    const refreshButtonLabel = refreshButton ? refreshButton.textContent : '';

    const normalizeConcept = (item) => {
      if (!item || typeof item !== 'object') {
        return {
          name: '',
          definition: '',
          examples: [],
          issue: '',
          outlineId: '',
        };
      }

      const examplesRaw = Array.isArray(item.examples) ? item.examples : [];
      const examples = examplesRaw
        .map((entry) => (typeof entry === 'string' ? entry.trim() : String(entry || '').trim()))
        .filter((entry) => entry);

      return {
        name: typeof item.name === 'string' ? item.name.trim() : '',
        definition: typeof item.definition === 'string' ? item.definition.trim() : '',
        examples,
        issue: typeof item.issue === 'string' ? item.issue.trim() : '',
        outlineId: item.outline_id != null ? String(item.outline_id) : '',
      };
    };

    let state = {
      outlineId: String(panel.getAttribute('data-concept-outline') || ''),
      concepts: [],
      usedFallback: panel.getAttribute('data-concept-used-fallback') === 'true',
    };

    try {
      const raw = panel.getAttribute('data-concept-concepts') || '[]';
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        state.concepts = parsed.map((entry) => normalizeConcept(entry));
      }
    } catch (error) {
      console.warn('Unable to parse concept definitions', error);
      state.concepts = [];
    }

    const toneClasses = {
      success: 'text-success',
      warning: 'text-warning',
      danger: 'text-danger',
      muted: 'text-white-50',
    };

    const updateStatus = (message, tone = 'muted') => {
      if (!statusNode) {
        return;
      }
      Object.values(toneClasses).forEach((cls) => statusNode.classList.remove(cls));
      const toneClass = toneClasses[tone] || toneClasses.muted;
      statusNode.classList.add(toneClass);
      statusNode.textContent = message;
    };

    const getSelectedOutline = () => {
      if (!outlineSelect) {
        return '';
      }
      return outlineSelect.value || '';
    };

    const updateButtonState = () => {
      if (!refreshButton) {
        return;
      }
      const hasOutline = Boolean(getSelectedOutline());
      refreshButton.disabled = !endpoint || !hasOutline;
    };

    const renderConcepts = () => {
      if (!listContainer) {
        return;
      }
      const selected = getSelectedOutline();
      const matches = state.concepts.length > 0 && (!selected || state.outlineId === selected);

      listContainer.innerHTML = '';
      if (matches) {
        state.concepts.forEach((concept) => {
          const article = document.createElement('article');
          article.className = 'concept-entry';

          const header = document.createElement('div');
          header.className = 'd-flex justify-content-between align-items-start mb-2';

          const title = document.createElement('h3');
          title.className = 'h6 text-white mb-0';
          title.textContent = concept.name || 'Unnamed concept';
          header.appendChild(title);

          if (concept.issue) {
            const badge = document.createElement('span');
            badge.className = 'badge rounded-pill bg-dark-subtle text-white-50 small';
            badge.textContent = 'Needs clarity';
            header.appendChild(badge);
          }

          article.appendChild(header);

          if (concept.issue) {
            const issue = document.createElement('p');
            issue.className = 'text-white-50 small mb-2 concept-issue';
            issue.textContent = concept.issue;
            article.appendChild(issue);
          }

          if (concept.definition) {
            const definition = document.createElement('p');
            definition.className = 'text-white-50 mb-2';
            definition.textContent = concept.definition;
            article.appendChild(definition);
          }

          if (concept.examples && concept.examples.length) {
            const list = document.createElement('ul');
            list.className = 'concept-examples';
            concept.examples.forEach((example) => {
              const item = document.createElement('li');
              item.textContent = example;
              list.appendChild(item);
            });
            article.appendChild(list);
          }

          listContainer.appendChild(article);
        });
      }

      if (emptyState) {
        emptyState.classList.toggle('d-none', matches);
      }
      if (fallbackNotice) {
        fallbackNotice.classList.toggle('d-none', !(state.usedFallback && matches));
      }
    };

    const toggleLoading = (isLoading) => {
      if (!refreshButton) {
        return;
      }
      if (isLoading) {
        refreshButton.setAttribute('disabled', 'disabled');
        refreshButton.textContent = 'Clarifying…';
      } else {
        updateButtonState();
        refreshButton.textContent = refreshButtonLabel || 'Clarify concepts';
      }
    };

    if (outlineSelect && state.outlineId) {
      const hasOption = Array.from(outlineSelect.options || []).some((option) => option.value === state.outlineId);
      if (hasOption) {
        outlineSelect.value = state.outlineId;
      }
    }

    updateButtonState();
    renderConcepts();

    if (!outlineSelect || outlineSelect.options.length <= 1) {
      updateStatus('Add an outline to unlock concept clarifications.', 'muted');
    }

    if (outlineSelect) {
      outlineSelect.addEventListener('change', () => {
        updateButtonState();
        const selected = getSelectedOutline();
        if (!selected) {
          updateStatus('Pick an outline to review and clarify its concepts.', 'muted');
        } else if (!state.concepts.length || state.outlineId !== selected) {
          updateStatus('No concepts generated for this outline yet.', 'muted');
        } else {
          const conceptCount = state.concepts.length;
          const tone = state.usedFallback ? 'warning' : 'success';
          updateStatus(
            `${conceptCount} concept${conceptCount === 1 ? '' : 's'} clarified. Generate again to refresh.`,
            tone,
          );
        }
        renderConcepts();
      });
    }

    if (refreshButton) {
      refreshButton.addEventListener('click', async () => {
        const outlineId = getSelectedOutline();
        if (!outlineId) {
          updateStatus('Select an outline before clarifying concepts.', 'warning');
          if (outlineSelect) {
            outlineSelect.focus();
          }
          return;
        }
        if (!endpoint) {
          updateStatus('Concept generation is not available right now.', 'danger');
          return;
        }

        toggleLoading(true);
        updateStatus('Clarifying concepts…', 'muted');

        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrfToken || '',
              'X-CSRF-Token': csrfToken || '',
            },
            body: JSON.stringify({ outline_id: outlineId }),
          });

          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to clarify concepts right now.');
          }

          const conceptsArray = Array.isArray(payload.concepts) ? payload.concepts : [];
          state = {
            outlineId: payload.outline_id != null ? String(payload.outline_id) : outlineId,
            concepts: conceptsArray.map((entry) => normalizeConcept(entry)),
            usedFallback: Boolean(payload.used_fallback),
          };

          if (outlineSelect && outlineSelect.value !== state.outlineId) {
            const hasOption = Array.from(outlineSelect.options || []).some(
              (option) => option.value === state.outlineId,
            );
            if (hasOption) {
              outlineSelect.value = state.outlineId;
            }
          }

          const count = state.concepts.length;
          if (count) {
            const tone = state.usedFallback ? 'warning' : 'success';
            const suffix = state.usedFallback
              ? 'Review the fallback suggestions for accuracy.'
              : 'Definitions saved to the project.';
            updateStatus(
              `${count} concept${count === 1 ? '' : 's'} clarified. ${suffix}`,
              tone,
            );
          } else {
            updateStatus('No concepts were identified. Try refining the outline and run again.', 'warning');
          }

          renderConcepts();
        } catch (error) {
          const message = error instanceof Error ? error.message : 'We could not clarify concepts right now.';
          updateStatus(message, 'danger');
        } finally {
          toggleLoading(false);
        }
      });
    }

    const initialSelected = getSelectedOutline();
    if (initialSelected) {
      if (state.concepts.length && state.outlineId === initialSelected) {
        const count = state.concepts.length;
        const tone = state.usedFallback ? 'warning' : 'success';
        updateStatus(
          `${count} concept${count === 1 ? '' : 's'} clarified. Generate again to refresh.`,
          tone,
        );
      } else if (!state.concepts.length) {
        updateStatus('No concepts generated for this outline yet.', 'muted');
      }
    } else if (outlineSelect && outlineSelect.options.length > 1) {
      updateStatus('No concepts generated for this outline yet.', 'muted');
    }
  })();

  (function () {
    const roster = document.querySelector('[data-character-roster]');
    const form = document.querySelector('[data-character-form]');
    if (!roster || !form) {
      return;
    }

    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    const csrfToken = csrfMeta ? csrfMeta.getAttribute('content') : '';

    const fields = Array.from(form.querySelectorAll('[data-character-field]'));
    const titleNode = form.querySelector('[data-character-form-title]');
    const subtitleNode = form.querySelector('[data-character-form-subtitle]');
    const statusNode = form.querySelector('[data-character-form-status]');
    const newButton = document.querySelector('[data-character-new]');
    const tiles = Array.from(roster.querySelectorAll('[data-character-entry]'));
    const autofillEndpoint = form.getAttribute('data-autofill-endpoint');
    const autofillField = form.querySelector('[data-character-autofill-field]');
    const autofillButton = form.querySelector('[data-character-autofill-button]');
    const autofillStatus = form.querySelector('[data-character-autofill-status]');
    const idField = form.querySelector('[data-character-field="id"]');
    const nameInput = form.querySelector('[data-character-field="name"]');

    const parseCharacter = (element) => {
      if (!element) {
        return null;
      }
      const raw = element.getAttribute('data-character');
      if (!raw) {
        return null;
      }
      try {
        return JSON.parse(raw);
      } catch (error) {
        console.warn('Unable to parse character data', error);
        return null;
      }
    };

    const updateUrl = (id) => {
      const url = new URL(window.location.href);
      if (id) {
        url.searchParams.set('character_id', id);
      } else {
        url.searchParams.delete('character_id');
      }
      window.history.replaceState({}, '', url);
    };

    const setActiveTile = (tile) => {
      tiles.forEach((entry) => {
        entry.classList.toggle('is-active', entry === tile);
      });
    };

    const applyCopy = (character) => {
      const hasCharacter = Boolean(character && character.id);
      const titleTemplate = form.getAttribute(hasCharacter ? 'data-title-edit' : 'data-title-new') || '';
      const subtitleTemplate = form.getAttribute(hasCharacter ? 'data-subtitle-edit' : 'data-subtitle-new') || '';
      const fallbackName = character && character.name ? character.name : 'character';
      if (titleNode) {
        titleNode.textContent = titleTemplate.replace('{name}', fallbackName);
      }
      if (subtitleNode) {
        subtitleNode.textContent = subtitleTemplate.replace('{name}', fallbackName);
      }
      if (statusNode) {
        statusNode.textContent = hasCharacter
          ? `Currently editing ${fallbackName}.`
          : 'Ready to capture a new character.';
      }
    };

    const applyFields = (character) => {
      const hasCharacter = Boolean(character && character.id);
      fields.forEach((input) => {
        const field = input.getAttribute('data-character-field');
        if (!field) {
          return;
        }
        if (field === 'id') {
          input.value = hasCharacter ? String(character.id) : '';
          return;
        }
        const hasValue = hasCharacter && Object.prototype.hasOwnProperty.call(character, field) && character[field] !== null;
        const value = hasValue ? String(character[field]) : '';
        input.value = value;
      });
    };

    const applyCharacter = (character, tile) => {
      applyFields(character);
      applyCopy(character);
      setActiveTile(tile || null);
    };

    const toneClasses = {
      success: 'text-success',
      warning: 'text-warning',
      danger: 'text-danger',
      muted: 'text-white-50',
    };

    const setAutofillStatus = (message, tone = 'muted') => {
      if (!autofillStatus) {
        return;
      }
      Object.values(toneClasses).forEach((cls) => {
        autofillStatus.classList.remove(cls);
      });
      const toneClass = toneClasses[tone] || toneClasses.muted;
      autofillStatus.classList.add(toneClass);
      autofillStatus.textContent = message;
    };

    const autofillButtonLabel = autofillButton ? autofillButton.textContent : '';

    const toggleAutofillLoading = (isLoading) => {
      if (!autofillButton) {
        return;
      }
      if (isLoading) {
        autofillButton.setAttribute('disabled', 'disabled');
        autofillButton.textContent = 'Generating…';
      } else {
        autofillButton.removeAttribute('disabled');
        autofillButton.textContent = autofillButtonLabel || 'Generate fields';
      }
    };

    if (autofillButton && autofillField && autofillEndpoint) {
      autofillButton.addEventListener('click', async () => {
        if (idField && idField.value) {
          setAutofillStatus('Switch to “Add new character” to generate a fresh profile.', 'warning');
          return;
        }

        const prompt = autofillField.value.trim();
        if (!prompt) {
          setAutofillStatus('Add a short description so the assistant knows what to create.', 'warning');
          autofillField.focus();
          return;
        }

        toggleAutofillLoading(true);
        setAutofillStatus('Asking the assistant for a draft…', 'muted');

        try {
          const response = await fetch(autofillEndpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrfToken || '',
              'X-CSRF-Token': csrfToken || '',
            },
            body: JSON.stringify({ prompt }),
          });

          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || 'Unable to generate a character profile right now.');
          }

          const profile = payload.profile || {};
          const normalized = {};
          ['name', 'role', 'background', 'goals', 'conflict', 'notes'].forEach((key) => {
            const value = Object.prototype.hasOwnProperty.call(profile, key) ? profile[key] : '';
            normalized[key] = typeof value === 'string' ? value : value != null ? String(value) : '';
          });

          applyFields(normalized);
          applyCopy(null);
          setActiveTile(null);

          if (idField) {
            idField.value = '';
          }
          if (statusNode) {
            statusNode.textContent = 'Draft generated from your prompt. Review before saving.';
          }
          if (nameInput) {
            nameInput.focus();
          }

          const tone = payload.used_fallback ? 'warning' : 'success';
          const message = payload.used_fallback
            ? 'Profile drafted with the backup generator. Refine the details before saving.'
            : 'Profile drafted. Review the fields and tailor them to your story.';
          setAutofillStatus(message, tone);
        } catch (error) {
          const message = error instanceof Error ? error.message : 'We could not generate a character right now.';
          setAutofillStatus(message, 'danger');
        } finally {
          toggleAutofillLoading(false);
        }
      });
    }

    tiles.forEach((tile) => {
      tile.addEventListener('click', (event) => {
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.button !== 0) {
          return;
        }
        event.preventDefault();
        const character = parseCharacter(tile);
        applyCharacter(character, tile);
        updateUrl(character && character.id ? character.id : null);
        if (nameInput) {
          nameInput.focus();
        }
      });
    });

    if (newButton) {
      newButton.addEventListener('click', (event) => {
        if (event.metaKey || event.ctrlKey || event.shiftKey) {
          return;
        }
        event.preventDefault();
        applyCharacter(null, null);
        updateUrl(null);
        if (nameInput) {
          nameInput.focus();
        }
      });
    }

    const initialId = roster.getAttribute('data-selected-id');
    if (initialId) {
      const initialTile = tiles.find((entry) => entry.getAttribute('data-character-id') === initialId);
      if (initialTile) {
        const initialCharacter = parseCharacter(initialTile);
        applyCharacter(initialCharacter, initialTile);
        return;
      }
    }
    applyCopy(null);
    setActiveTile(null);
  })();
</script>
{% endblock %}
